Goals of algorithm
	* Every set of honeywords generated must have the same pattern such that the output of the algorithm does not hint at the characteristics of the password.
	* Sweetwords must be typo-resistant.
	* Minimize or eliminate external libraries dependencies.
	* Language-agnostic -- It would be nice to have pseducode in several different styles, and several different implementations including C, Perl, Java, and Python.

High-level design
	* Given an input password, this algorithm should identify its characteristics and produce chaffing accordingly.
	* For a given k>30 sweetwords to generate, k/n=5 buckets will be created. n-1 buckets will contain 5 sweetwords. 1 bucket will contain the sugarword and 4 sweetwords. Each bucket's honeywords will have a similar pattern through identical chaffing strategies.
	* In addition to the characteristics, their ratio in respect to the length of the password, and each of their densities throughout the password will matter to the generation.
	* It would be nice to avoid a dictionary all together, but this may be impossible. Regardless, dictionary should be comprehensive -- only required during honeyword generation, never during authorization.
	* RNG where possible and with several layers of redundancies. Use trusted RNG.


Characteristic [zero, one, two, three, four, Eta]
	This refers to the number of numeric digits in the password.

Characteristic [A, B, C, D, E...]
	This refers to the number of non-alphanumeric characters in the password.

Characteristic [alpha, beta, gamma, deta, epsilon, zeta...]
	This refers to the number of words identified in the password.

Characteristic [red, orange, yellow, green, blue, indigo, violet]
	This refers to the number of alphanumeric characters not identified as a word or "noise."
